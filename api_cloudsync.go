/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dragonfish

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// CloudsyncApiService CloudsyncApi service
type CloudsyncApiService service

type ApiCloudsyncCommonTaskSchemaGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
}

func (r ApiCloudsyncCommonTaskSchemaGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncCommonTaskSchemaGetExecute(r)
}

/*
CloudsyncCommonTaskSchemaGet Method for CloudsyncCommonTaskSchemaGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncCommonTaskSchemaGetRequest
*/
func (a *CloudsyncApiService) CloudsyncCommonTaskSchemaGet(ctx context.Context) ApiCloudsyncCommonTaskSchemaGetRequest {
	return ApiCloudsyncCommonTaskSchemaGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncCommonTaskSchemaGetExecute(r ApiCloudsyncCommonTaskSchemaGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncCommonTaskSchemaGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/common_task_schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiCloudsyncGetRequest) Limit(limit int32) ApiCloudsyncGetRequest {
	r.limit = &limit
	return r
}

func (r ApiCloudsyncGetRequest) Offset(offset int32) ApiCloudsyncGetRequest {
	r.offset = &offset
	return r
}

func (r ApiCloudsyncGetRequest) Count(count bool) ApiCloudsyncGetRequest {
	r.count = &count
	return r
}

func (r ApiCloudsyncGetRequest) Sort(sort string) ApiCloudsyncGetRequest {
	r.sort = &sort
	return r
}

func (r ApiCloudsyncGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncGetExecute(r)
}

/*
CloudsyncGet Method for CloudsyncGet

Query all Cloud Sync Tasks with `query-filters` and `query-options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncGetRequest
*/
func (a *CloudsyncApiService) CloudsyncGet(ctx context.Context) ApiCloudsyncGetRequest {
	return ApiCloudsyncGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncGetExecute(r ApiCloudsyncGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdAbortPostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
	body       *map[string]interface{}
}

func (r ApiCloudsyncIdIdAbortPostRequest) Body(body map[string]interface{}) ApiCloudsyncIdIdAbortPostRequest {
	r.body = &body
	return r
}

func (r ApiCloudsyncIdIdAbortPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdAbortPostExecute(r)
}

/*
CloudsyncIdIdAbortPost Method for CloudsyncIdIdAbortPost

Aborts cloud sync task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdAbortPostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdAbortPost(ctx context.Context, id int32) ApiCloudsyncIdIdAbortPostRequest {
	return ApiCloudsyncIdIdAbortPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdAbortPostExecute(r ApiCloudsyncIdIdAbortPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdAbortPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/abort"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r ApiCloudsyncIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdDeleteExecute(r)
}

/*
CloudsyncIdIdDelete Method for CloudsyncIdIdDelete

Deletes cloud_sync entry `id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdDeleteRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdDelete(ctx context.Context, id int32) ApiCloudsyncIdIdDeleteRequest {
	return ApiCloudsyncIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdDeleteExecute(r ApiCloudsyncIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiCloudsyncIdIdGetRequest) Limit(limit int32) ApiCloudsyncIdIdGetRequest {
	r.limit = &limit
	return r
}

func (r ApiCloudsyncIdIdGetRequest) Offset(offset int32) ApiCloudsyncIdIdGetRequest {
	r.offset = &offset
	return r
}

func (r ApiCloudsyncIdIdGetRequest) Count(count bool) ApiCloudsyncIdIdGetRequest {
	r.count = &count
	return r
}

func (r ApiCloudsyncIdIdGetRequest) Sort(sort string) ApiCloudsyncIdIdGetRequest {
	r.sort = &sort
	return r
}

func (r ApiCloudsyncIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdGetExecute(r)
}

/*
CloudsyncIdIdGet Method for CloudsyncIdIdGet

Query all Cloud Sync Tasks with `query-filters` and `query-options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdGetRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdGet(ctx context.Context, id int32) ApiCloudsyncIdIdGetRequest {
	return ApiCloudsyncIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdGetExecute(r ApiCloudsyncIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdPutRequest struct {
	ctx              context.Context
	ApiService       *CloudsyncApiService
	id               int32
	cloudsyncUpdate1 *CloudsyncUpdate1
}

func (r ApiCloudsyncIdIdPutRequest) CloudsyncUpdate1(cloudsyncUpdate1 CloudsyncUpdate1) ApiCloudsyncIdIdPutRequest {
	r.cloudsyncUpdate1 = &cloudsyncUpdate1
	return r
}

func (r ApiCloudsyncIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdPutExecute(r)
}

/*
CloudsyncIdIdPut Method for CloudsyncIdIdPut

Updates the cloud_sync entry `id` with `data`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdPutRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdPut(ctx context.Context, id int32) ApiCloudsyncIdIdPutRequest {
	return ApiCloudsyncIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdPutExecute(r ApiCloudsyncIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncUpdate1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdRestorePostRequest struct {
	ctx               context.Context
	ApiService        *CloudsyncApiService
	id                int32
	cloudsyncRestore1 *CloudsyncRestore1
}

func (r ApiCloudsyncIdIdRestorePostRequest) CloudsyncRestore1(cloudsyncRestore1 CloudsyncRestore1) ApiCloudsyncIdIdRestorePostRequest {
	r.cloudsyncRestore1 = &cloudsyncRestore1
	return r
}

func (r ApiCloudsyncIdIdRestorePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdRestorePostExecute(r)
}

/*
CloudsyncIdIdRestorePost Method for CloudsyncIdIdRestorePost

Create the opposite of cloud sync task `id` (PULL if it was PUSH and vice versa).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdRestorePostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdRestorePost(ctx context.Context, id int32) ApiCloudsyncIdIdRestorePostRequest {
	return ApiCloudsyncIdIdRestorePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdRestorePostExecute(r ApiCloudsyncIdIdRestorePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdRestorePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncRestore1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncIdIdSyncPostRequest struct {
	ctx            context.Context
	ApiService     *CloudsyncApiService
	id             int32
	cloudsyncSync1 *CloudsyncSync1
}

func (r ApiCloudsyncIdIdSyncPostRequest) CloudsyncSync1(cloudsyncSync1 CloudsyncSync1) ApiCloudsyncIdIdSyncPostRequest {
	r.cloudsyncSync1 = &cloudsyncSync1
	return r
}

func (r ApiCloudsyncIdIdSyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdSyncPostExecute(r)
}

/*
CloudsyncIdIdSyncPost Method for CloudsyncIdIdSyncPost

Run the cloud_sync job `id`, syncing the local data to remote.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCloudsyncIdIdSyncPostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdSyncPost(ctx context.Context, id int32) ApiCloudsyncIdIdSyncPostRequest {
	return ApiCloudsyncIdIdSyncPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdSyncPostExecute(r ApiCloudsyncIdIdSyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdSyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncSync1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncListBucketsPostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	body       *int32
}

func (r ApiCloudsyncListBucketsPostRequest) Body(body int32) ApiCloudsyncListBucketsPostRequest {
	r.body = &body
	return r
}

func (r ApiCloudsyncListBucketsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncListBucketsPostExecute(r)
}

/*
CloudsyncListBucketsPost Method for CloudsyncListBucketsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncListBucketsPostRequest
*/
func (a *CloudsyncApiService) CloudsyncListBucketsPost(ctx context.Context) ApiCloudsyncListBucketsPostRequest {
	return ApiCloudsyncListBucketsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncListBucketsPostExecute(r ApiCloudsyncListBucketsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncListBucketsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/list_buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncListDirectoryPostRequest struct {
	ctx                     context.Context
	ApiService              *CloudsyncApiService
	cloudsyncListDirectory0 *CloudsyncListDirectory0
}

func (r ApiCloudsyncListDirectoryPostRequest) CloudsyncListDirectory0(cloudsyncListDirectory0 CloudsyncListDirectory0) ApiCloudsyncListDirectoryPostRequest {
	r.cloudsyncListDirectory0 = &cloudsyncListDirectory0
	return r
}

func (r ApiCloudsyncListDirectoryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncListDirectoryPostExecute(r)
}

/*
CloudsyncListDirectoryPost Method for CloudsyncListDirectoryPost

List contents of a remote bucket / directory.

If remote supports buckets, path is constructed by two keys "bucket"/"folder" in `attributes`.
If remote does not support buckets, path is constructed using "folder" key only in `attributes`.
"folder" is directory name and "bucket" is bucket name for remote.

Path examples:

S3 Service
`bucketname/directory/name`

Dropbox Service
`directory/name`

`credentials` is a valid id of a Cloud Sync Credential which will be used to connect to the provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncListDirectoryPostRequest
*/
func (a *CloudsyncApiService) CloudsyncListDirectoryPost(ctx context.Context) ApiCloudsyncListDirectoryPostRequest {
	return ApiCloudsyncListDirectoryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncListDirectoryPostExecute(r ApiCloudsyncListDirectoryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncListDirectoryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/list_directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncListDirectory0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncOnedriveListDrivesPostRequest struct {
	ctx                          context.Context
	ApiService                   *CloudsyncApiService
	cloudsyncOnedriveListDrives0 *CloudsyncOnedriveListDrives0
}

func (r ApiCloudsyncOnedriveListDrivesPostRequest) CloudsyncOnedriveListDrives0(cloudsyncOnedriveListDrives0 CloudsyncOnedriveListDrives0) ApiCloudsyncOnedriveListDrivesPostRequest {
	r.cloudsyncOnedriveListDrives0 = &cloudsyncOnedriveListDrives0
	return r
}

func (r ApiCloudsyncOnedriveListDrivesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncOnedriveListDrivesPostExecute(r)
}

/*
CloudsyncOnedriveListDrivesPost Method for CloudsyncOnedriveListDrivesPost

Lists all available drives and their types for given Microsoft OneDrive credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncOnedriveListDrivesPostRequest
*/
func (a *CloudsyncApiService) CloudsyncOnedriveListDrivesPost(ctx context.Context) ApiCloudsyncOnedriveListDrivesPostRequest {
	return ApiCloudsyncOnedriveListDrivesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncOnedriveListDrivesPostExecute(r ApiCloudsyncOnedriveListDrivesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncOnedriveListDrivesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/onedrive_list_drives"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncOnedriveListDrives0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncPostRequest struct {
	ctx              context.Context
	ApiService       *CloudsyncApiService
	cloudsyncCreate0 *CloudsyncCreate0
}

func (r ApiCloudsyncPostRequest) CloudsyncCreate0(cloudsyncCreate0 CloudsyncCreate0) ApiCloudsyncPostRequest {
	r.cloudsyncCreate0 = &cloudsyncCreate0
	return r
}

func (r ApiCloudsyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncPostExecute(r)
}

/*
CloudsyncPost Method for CloudsyncPost

Creates a new cloud_sync entry.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncPostRequest
*/
func (a *CloudsyncApiService) CloudsyncPost(ctx context.Context) ApiCloudsyncPostRequest {
	return ApiCloudsyncPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncPostExecute(r ApiCloudsyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncProvidersGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
}

func (r ApiCloudsyncProvidersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncProvidersGetExecute(r)
}

/*
CloudsyncProvidersGet Method for CloudsyncProvidersGet

Returns a list of dictionaries of supported providers for Cloud Sync Tasks.

`credentials_schema` is JSON schema for credentials attributes.

`task_schema` is JSON schema for task attributes.

`buckets` is a boolean value which is set to "true" if provider supports buckets.

Example of a single provider:

[

	{
	    "name": "AMAZON_CLOUD_DRIVE",
	    "title": "Amazon Cloud Drive",
	    "credentials_schema": [
	        {
	            "property": "client_id",
	            "schema": {
	                "title": "Amazon Application Client ID",
	                "_required_": true,
	                "type": "string"
	            }
	        },
	        {
	            "property": "client_secret",
	            "schema": {
	                "title": "Application Key",
	                "_required_": true,
	                "type": "string"
	            }
	        }
	    ],
	    "credentials_oauth": null,
	    "buckets": false,
	    "bucket_title": "Bucket",
	    "task_schema": []
	}

]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncProvidersGetRequest
*/
func (a *CloudsyncApiService) CloudsyncProvidersGet(ctx context.Context) ApiCloudsyncProvidersGetRequest {
	return ApiCloudsyncProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncProvidersGetExecute(r ApiCloudsyncProvidersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncProvidersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloudsyncSyncOnetimePostRequest struct {
	ctx                  context.Context
	ApiService           *CloudsyncApiService
	cloudsyncSyncOnetime *CloudsyncSyncOnetime
}

func (r ApiCloudsyncSyncOnetimePostRequest) CloudsyncSyncOnetime(cloudsyncSyncOnetime CloudsyncSyncOnetime) ApiCloudsyncSyncOnetimePostRequest {
	r.cloudsyncSyncOnetime = &cloudsyncSyncOnetime
	return r
}

func (r ApiCloudsyncSyncOnetimePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncSyncOnetimePostExecute(r)
}

/*
CloudsyncSyncOnetimePost Method for CloudsyncSyncOnetimePost

Run cloud sync task without creating it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloudsyncSyncOnetimePostRequest
*/
func (a *CloudsyncApiService) CloudsyncSyncOnetimePost(ctx context.Context) ApiCloudsyncSyncOnetimePostRequest {
	return ApiCloudsyncSyncOnetimePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncSyncOnetimePostExecute(r ApiCloudsyncSyncOnetimePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncSyncOnetimePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/sync_onetime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncSyncOnetime
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
